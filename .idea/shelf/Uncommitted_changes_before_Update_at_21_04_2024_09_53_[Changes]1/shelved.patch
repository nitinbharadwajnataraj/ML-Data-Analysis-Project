Index: app.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import streamlit as st\r\nimport pandas as pd\r\nimport numpy as np\r\nfrom plotly.subplots import make_subplots\r\n\r\nfrom create_fake_data import create_fake_dataset\r\nfrom data_model import data_model as box_data_model\r\nfrom k_means import perform_kmeans\r\nimport plotly.express as px\r\nimport plotly.graph_objects as go\r\nfrom create_fake_data import create_fake_dataset\r\nfrom Compute_fit import compute_fit,count_yes_no\r\n\r\n\r\n\r\nst.set_page_config(layout=\"wide\")\r\n\r\n\r\ndef df_return():\r\n    df = create_fake_dataset()\r\n    return df\r\n\r\n\r\ndef scatter_plot():\r\n    st.markdown(\r\n        f'<h1 style=\"text-align: center;\">Box and Cylinder Analysis</h1>',\r\n        unsafe_allow_html=True\r\n    )\r\n    df = df_return()\r\n    df_1 = compute_fit()\r\n    df_1 = df_1.drop(columns=['ID'], axis=1)\r\n\r\n    # Allow users to choose columns for the scatter plot\r\n    selected_columns = st.multiselect(\"Select columns for scatter plot\", df_1.columns)\r\n\r\n    # Define colors for \"yes\" and \"no\" values\r\n    yes_color = 'green'\r\n    no_color = 'red'\r\n\r\n    # Create scatter plot if at least two columns are selected\r\n    if len(selected_columns) >= 2:\r\n        st.write(\"Scatter Plot:\")\r\n        fig = go.Figure()\r\n        for col in selected_columns:\r\n            # Set color based on 'check' value\r\n            colors = [yes_color if val == 'yes' else no_color for val in df_1[\"check\"]]\r\n            fig.add_trace(go.Scatter(x=df_1.index, y=df_1[col], mode='markers', name=col, marker=dict(color=colors)))\r\n        st.plotly_chart(fig)\r\n    else:\r\n        st.warning(\"Please select at least two columns for the scatter plot.\")\r\n\r\n\r\n# def scatter_plot():\r\n#     # Center the title\r\n#\r\n#     df = df_return()\r\n#     st.write(df)\r\n#     # Allow users to choose columns for the scatter plot\r\n#     # selected_columns = st.multiselect(\"Select columns for scatter plot\", df.columns)\r\n#\r\n#     # Create scatter plot if at least two columns are selected\r\n#     for column in df.columns[1:]:  # Exclude 'ID' column\r\n#         st.write(\"Scatter Plot:\")\r\n#         fig = go.Figure()\r\n#         fig.add_trace(go.Scatter(x=df.index, y=df[column], mode='markers', name=column))\r\n#         st.plotly_chart(fig)\r\n#         return fig\r\n\r\ndef box_plot():\r\n    df = df_return()\r\n    fig = go.Figure()\r\n    for column in df.columns[1:]:  # Exclude 'ID' column\r\n        fig.add_trace(go.Box(y=df[column], name=column))\r\n    fig.update_layout(title='Box Plot(Fake_data understanding)', xaxis_title='Parameters', yaxis_title='Values')\r\n    st.plotly_chart(fig)\r\n    return fig\r\n\r\n\r\ndef bar_chart():\r\n    df_1, count_yes, count_no = count_yes_no()\r\n    distinct_check_value = list(set(df_1['check']))\r\n    data = {\r\n        'Category': distinct_check_value,\r\n        'Value': [count_yes, count_no]\r\n    }\r\n    df = pd.DataFrame(data)\r\n\r\n    # Create bar chart\r\n    fig = go.Figure(data=[go.Bar(x=df['Category'], y=df['Value'])])\r\n    fig.update_layout(title='Bar Chart', xaxis_title='Category', yaxis_title='Value')\r\n\r\n    # Display the chart in Streamlit\r\n    st.plotly_chart(fig)\r\n\r\n\r\ndef df_return():\r\n    df = create_fake_dataset()\r\n    return df\r\n\r\ndef kmeans():\r\n    sections = {\r\n        'Clusters 4 Operators': 'section-1'\r\n    }\r\n\r\n    st.header(\"KMeans Data Performance\")\r\n\r\n    num_clusters = \"Automatic\"\r\n    if num_clusters == \"Automatic\":\r\n        num_clusters = None\r\n\r\n    fake_data = df_return()\r\n    if \"engineering_df\" not in st.session_state:\r\n        engineering_df = pd.read_excel(\"engineered_data_for_cluster.xlsx\")\r\n        st.session_state[\"engineering_df\"] = engineering_df\r\n        st.write(fake_data)\r\n\r\n    st.header(\"Clusters 4 Operators\", anchor=sections['Clusters 4 Operators'])\r\n    df = df_return()\r\n\r\n    num_clusters = st.selectbox('Number of clusters', [\"Automatic\", 2, 3, 4, 5, 6, 7, 8, 9, 10], index=3)\r\n\r\n    if num_clusters == \"Automatic\":\r\n        num_clusters = None\r\n\r\n    columns = df.columns.tolist()\r\n    cluster_columns = st.multiselect('Select columns for clustering', columns, default=columns[2:6])\r\n    fake_data = df[cluster_columns].values\r\n\r\n    cluster_labels, cluster_centers, inertia, optimal_k = perform_kmeans(fake_data, num_clusters)\r\n    center_df = pd.DataFrame(cluster_centers, columns=cluster_columns)\r\n    cluster_names = [f'Cluster {i}' for i in range(optimal_k)]\r\n    center_df['Name'] = cluster_names\r\n    engineering_df = pd.read_excel(\"engineered_data_for_cluster.xlsx\")  # check df session control\r\n    cluster_df = center_df\r\n\r\n    st.subheader('Cluster Centers', anchor='cluster-centers')\r\n    cluster_df[\"index_num\"] = cluster_df.index\r\n    figures = []\r\n\r\n    for column in cluster_columns:\r\n        fig = px.scatter(cluster_df, x=\"index_num\", y=column, color=\"Name\")\r\n        fig.update_traces(marker={'size': 15})\r\n\r\n        # Add horizontal lines for target, min, and max values from the target DataFrame\r\n        if column in engineering_df['name'].values:\r\n            target_value = engineering_df.loc[engineering_df['name'] == column, 'target'].values[0]\r\n            min_value = engineering_df.loc[engineering_df['name'] == column, 'min'].values[0]\r\n            max_value = engineering_df.loc[engineering_df['name'] == column, 'max'].values[0]\r\n\r\n            fig.add_shape(type=\"line\", x0=0, y0=target_value, x1=len(cluster_df[column]) - 1, y1=target_value,\r\n                          line=dict(color=\"green\", width=1), name='target')\r\n            fig.add_shape(type=\"line\", x0=0, y0=min_value, x1=len(cluster_df[column]) - 1, y1=min_value,\r\n                          line=dict(color=\"violet\", width=1), name='min')\r\n            fig.add_shape(type=\"line\", x0=0, y0=max_value, x1=len(cluster_df[column]) - 1, y1=max_value,\r\n                          line=dict(color=\"red\", width=1), name='max')\r\n\r\n        # Update layout\r\n        fig.update_layout(title=f\"Cluster Centers for {column}\",\r\n                          xaxis_title=\"Cluster Index\",\r\n                          yaxis_title=column)\r\n        # Add the figure to the list\r\n        figures.append(fig)\r\n\r\n    # Display the figures in a row format\r\n    for fig in figures:\r\n        st.plotly_chart(fig)\r\n\r\n\r\n    # Calculate max and min values for each cluster\r\n    cluster_max_values = []\r\n    cluster_min_values = []\r\n\r\n    for i in range(optimal_k):\r\n        cluster_data = fake_data[cluster_labels == i]  # Get data points belonging to cluster i\r\n        cluster_max = np.max(cluster_data, axis=0)  # Calculate max values for each feature in the cluster\r\n        cluster_min = np.min(cluster_data, axis=0)  # Calculate min values for each feature in the cluster\r\n        cluster_max_values.append(cluster_max)\r\n        cluster_min_values.append(cluster_min)\r\n\r\n    # Convert max and min values to DataFrame\r\n    max_df = pd.DataFrame(cluster_max_values, columns=cluster_columns)\r\n    min_df = pd.DataFrame(cluster_min_values, columns=cluster_columns)\r\n\r\n    # Add cluster names\r\n    max_df['Cluster'] = [f'Cluster {i}' for i in range(optimal_k)]\r\n    min_df['Cluster'] = [f'Cluster {i}' for i in range(optimal_k)]\r\n\r\n    # Display max and min values\r\n    # st.subheader('Max and Min Values for Each Cluster')\r\n    # st.write(\"Max Values:\")\r\n    # st.write(max_df)\r\n    # st.write(\"Min Values:\")\r\n    # st.write(min_df)\r\n\r\n    # Define a color palette for clusters\r\n    colors = px.colors.qualitative.Set1\r\n\r\n    # Create subplots\r\n    fig = go.Figure()\r\n\r\n    # Plot min and max values for each column\r\n    for i, column in enumerate(cluster_columns):\r\n        for j in range(optimal_k):\r\n            fig.add_trace(go.Bar(x=[f'Cluster {j} - Min', f'Cluster {j} - Max'],\r\n                                 y=[min_df[column][j], max_df[column][j]],\r\n                                 name=column,\r\n                                 marker_color=colors[j]))\r\n\r\n    # Update layout\r\n    fig.update_layout(title=\"Min and Max Values for Each Cluster\",\r\n                      xaxis_title=\"Cluster\",\r\n                      yaxis_title=\"Value\",\r\n                      barmode='group')\r\n\r\n    st.plotly_chart(fig)\r\n\r\ndef main():\r\n    scatter_plot()\r\n    box_plot()\r\n    bar_chart()\r\n    kmeans()\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app.py b/app.py
--- a/app.py	
+++ b/app.py	
@@ -1,108 +1,181 @@
 import streamlit as st
 import pandas as pd
 import numpy as np
-from plotly.subplots import make_subplots
-
-from create_fake_data import create_fake_dataset
-from data_model import data_model as box_data_model
-from k_means import perform_kmeans
-import plotly.express as px
 import plotly.graph_objects as go
+import plotly.express as px
+from data_model import data_model
 from create_fake_data import create_fake_dataset
-from Compute_fit import compute_fit,count_yes_no
-
-
+from Compute_fit import compute_fit, count_yes_no
+from k_means import perform_kmeans
 
 st.set_page_config(layout="wide")
 
-
 def df_return():
     df = create_fake_dataset()
     return df
 
 
+def color_code(val):
+    if val == 'OK':
+        color = 'green'
+    elif val == 'NOK':
+        color = 'red'
+    elif val == 'Transition':
+        color = 'lightblue'
+    elif val == 'Clearance':
+        color = 'yellow'
+    else:
+        color = 'grey'
+    return f'background-color: {color}'
+def df_fitting_and_evaluation():
+    df = df_return()
+    df["fitting"] = df["box_hole_diameter"] - df["cylinder_diameter"]
+
+    # Using & instead of 'and'
+    condition1 = (df["fitting"] <= 1) & (df["fitting"] >= -1)
+    condition2 = (df["fitting"] > 1)
+
+    # Assigning values based on conditions
+    df.loc[condition1, "Evaluation"] = 'OK'
+    df.loc[condition1, "fitting_group"] = 'Transition'
+    df.loc[condition2, "Evaluation"] = 'NOK'
+    df.loc[condition2, "fitting_group"] = 'Clearance'
+    df.loc[~(condition1 | condition2), "Evaluation"] = 'NOK'
+    df.loc[~(condition1 | condition2), "fitting_group"] = 'Excess'
+
+    styled_df = df.style.applymap(color_code, subset=['Evaluation', 'fitting_group'])
+
+    return df, styled_df
+
+
+def df_bar_chart_Evaluation():
+    df1, df2 = df_fitting_and_evaluation()
+    count_ok, count_nok = 0, 0
+    for val in df1["Evaluation"]:
+        if val == "OK":
+            count_ok += 1
+        elif val == 'NOK':
+            count_nok += 1
+
+    data = {'Category': ['OK','NOK'], 'Value': [count_ok, count_nok]}
+    df = pd.DataFrame(data)
+
+    fig = go.Figure(data=[go.Bar(x=df['Category'], y=df['Value'])])
+    fig.update_layout(title='Evaluation Results', xaxis_title='Category', yaxis_title='Value')
+    st.plotly_chart(fig)
+
+
+def df_bar_chart_fitting_group():
+    df1, df2 = df_fitting_and_evaluation()
+    count_transition, count_clearance, count_excess = 0, 0, 0
+    for val in df1["fitting_group"]:
+        if val == "Excess":
+            count_excess += 1
+        elif val == "Clearance":
+            count_clearance += 1
+        elif val == "Transition":
+            count_transition += 1
+
+    data = {'Category': ['Transition', 'Clearance', 'Excess'], 'Value': [count_transition, count_clearance, count_excess]}
+    df = pd.DataFrame(data)
+
+    fig = go.Figure(data=[go.Bar(x=df['Category'], y=df['Value'])])
+    fig.update_layout(title='Fitting Groups', xaxis_title='Category', yaxis_title='Value')
+    st.plotly_chart(fig)
+
 def scatter_plot():
-    st.markdown(
-        f'<h1 style="text-align: center;">Box and Cylinder Analysis</h1>',
-        unsafe_allow_html=True
-    )
-    df = df_return()
     df_1 = compute_fit()
     df_1 = df_1.drop(columns=['ID'], axis=1)
+    col1, col2 = st.columns([0.3,0.7])
+    with col1:
+        selected_shape = st.selectbox("Select shape for scatter plot", ["Box", "Cylinder"], key="select_shape")
 
-    # Allow users to choose columns for the scatter plot
-    selected_columns = st.multiselect("Select columns for scatter plot", df_1.columns)
+        if selected_shape:
+            if selected_shape == "Box":
+                related_columns = ["box_hole_diameter", "box_hole_depth"]
+            elif selected_shape == "Cylinder":
+                related_columns = ["cylinder_diameter", "cylinder_height"]
+            else:
+                related_columns = []
 
-    # Define colors for "yes" and "no" values
-    yes_color = 'green'
-    no_color = 'red'
+            selected_column = st.selectbox("Select a column for scatter plot", related_columns, key="select_column")
 
-    # Create scatter plot if at least two columns are selected
-    if len(selected_columns) >= 2:
-        st.write("Scatter Plot:")
-        fig = go.Figure()
-        for col in selected_columns:
-            # Set color based on 'check' value
-            colors = [yes_color if val == 'yes' else no_color for val in df_1["check"]]
-            fig.add_trace(go.Scatter(x=df_1.index, y=df_1[col], mode='markers', name=col, marker=dict(color=colors)))
-        st.plotly_chart(fig)
-    else:
-        st.warning("Please select at least two columns for the scatter plot.")
-
-
-# def scatter_plot():
-#     # Center the title
-#
-#     df = df_return()
-#     st.write(df)
-#     # Allow users to choose columns for the scatter plot
-#     # selected_columns = st.multiselect("Select columns for scatter plot", df.columns)
-#
-#     # Create scatter plot if at least two columns are selected
-#     for column in df.columns[1:]:  # Exclude 'ID' column
-#         st.write("Scatter Plot:")
-#         fig = go.Figure()
-#         fig.add_trace(go.Scatter(x=df.index, y=df[column], mode='markers', name=column))
-#         st.plotly_chart(fig)
-#         return fig
+            yes_color = '#FF7F0E'
+            no_color = 'grey'
+
+        with col2:
+            if selected_column:
+                st.write("Scatter Plot:")
+                fig = go.Figure()
+
+                colors = [yes_color if val == 'yes' else no_color for val in df_1["check"]]
+                fig.add_trace(go.Scatter(x=df_1.index, y=df_1[selected_column], mode='markers', name=selected_column,
+                                         marker=dict(color=colors)))
+
+                min_value = data_model[selected_shape][selected_column]["min_value"]
+                max_value = data_model[selected_shape][selected_column]["max_value"]
+                target_value = data_model[selected_shape][selected_column]["target_value"]
+
+                fig.add_shape(type="line", x0=df_1.index.min(), y0=min_value, x1=df_1.index.max(), y1=min_value,
+                              line=dict(color="red", width=1, dash="solid"))
+                fig.add_shape(type="line", x0=df_1.index.min(), y0=max_value, x1=df_1.index.max(), y1=max_value,
+                              line=dict(color="red", width=1, dash="solid"))
+                fig.add_shape(type="line", x0=df_1.index.min(), y0=target_value, x1=df_1.index.max(), y1=target_value,
+                              line=dict(color="lime", width=1, dash="solid"))
+
+                fig.add_annotation(
+                    x=df_1.index.min(),
+                    y=min_value,
+                    text="Minimum Value",
+                    showarrow=False,
+                    font=dict(size=12, color="red")
+                )
+                fig.add_annotation(
+                    x=df_1.index.min(),
+                    y=max_value,
+                    text="Maximum Value",
+                    showarrow=False,
+                    font=dict(size=12, color="red")
+                )
+                fig.add_annotation(
+                    x=df_1.index.min(),
+                    y=target_value,
+                    text="Target Value",
+                    showarrow=False,
+                    font=dict(size=12, color="lime")
+                )
+
+                st.plotly_chart(fig)
+            else:
+                st.warning("Please select a column for the scatter plot.")
 
 def box_plot():
     df = df_return()
     fig = go.Figure()
-    for column in df.columns[1:]:  # Exclude 'ID' column
+    for column in df.columns[1:]:
         fig.add_trace(go.Box(y=df[column], name=column))
     fig.update_layout(title='Box Plot(Fake_data understanding)', xaxis_title='Parameters', yaxis_title='Values')
     st.plotly_chart(fig)
-    return fig
-
 
 def bar_chart():
     df_1, count_yes, count_no = count_yes_no()
+    df2,df3 = df_fitting_and_evaluation()
+    st.dataframe(df3, width=800)
     distinct_check_value = list(set(df_1['check']))
-    data = {
-        'Category': distinct_check_value,
-        'Value': [count_yes, count_no]
-    }
+    data = {'Category': distinct_check_value, 'Value': [count_yes, count_no]}
     df = pd.DataFrame(data)
 
-    # Create bar chart
     fig = go.Figure(data=[go.Bar(x=df['Category'], y=df['Value'])])
     fig.update_layout(title='Bar Chart', xaxis_title='Category', yaxis_title='Value')
-
-    # Display the chart in Streamlit
     st.plotly_chart(fig)
 
-
-def df_return():
-    df = create_fake_dataset()
-    return df
+def kmeans_info_popover():
+    st.popover("K-Means analysis provides insights into data clustering. It helps in identifying patterns and grouping similar data points together. Select the number of clusters and features for clustering to visualize the results.")
 
 def kmeans():
-    sections = {
-        'Clusters 4 Operators': 'section-1'
-    }
+    sections = {'Clusters 4 Operators': 'section-1'}
 
-    st.header("KMeans Data Performance")
+    st.header("Synthetic Data")
 
     num_clusters = "Automatic"
     if num_clusters == "Automatic":
@@ -114,14 +187,37 @@
         st.session_state["engineering_df"] = engineering_df
         st.write(fake_data)
 
-    st.header("Clusters 4 Operators", anchor=sections['Clusters 4 Operators'])
+    st.header("Cluster Analysis", anchor=sections['Clusters 4 Operators'])
     df = df_return()
 
-    num_clusters = st.selectbox('Number of clusters', ["Automatic", 2, 3, 4, 5, 6, 7, 8, 9, 10], index=3)
+    # import streamlit as st
+    #
+    # popover = st.popover("Filter items")
+    # red = popover.checkbox("Show red items.", True)
+    # blue = popover.checkbox("Show blue items.", True)
+    #
+    # if red:
+    #     st.write(":red[This is a red item.]")
+    # if blue:
+    #     st.write(":blue[This is a blue item.]")
+
+    # popover = st.popover('Number of clusters')
+    # automatic = popover.checkbox('Automatic')
+    automatic_clusters = st.checkbox("Automatic", False)
+    if automatic_clusters:
+        num_clusters = None
+    else:
+        with st.popover(""):
+            st.markdown("Hello World 👋")
+            name = st.text_input("What's your name?")
+
+        st.write("Your name:", name)
+        num_clusters = st.popover('Number of clusters', [2, 3, 4, 5, 6, 7, 8, 9, 10], index=1)
 
     if num_clusters == "Automatic":
         num_clusters = None
 
+    df = df.drop(columns=['ID'], axis=1)
     columns = df.columns.tolist()
     cluster_columns = st.multiselect('Select columns for clustering', columns, default=columns[2:6])
     fake_data = df[cluster_columns].values
@@ -141,7 +237,6 @@
         fig = px.scatter(cluster_df, x="index_num", y=column, color="Name")
         fig.update_traces(marker={'size': 15})
 
-        # Add horizontal lines for target, min, and max values from the target DataFrame
         if column in engineering_df['name'].values:
             target_value = engineering_df.loc[engineering_df['name'] == column, 'target'].values[0]
             min_value = engineering_df.loc[engineering_df['name'] == column, 'min'].values[0]
@@ -154,72 +249,165 @@
             fig.add_shape(type="line", x0=0, y0=max_value, x1=len(cluster_df[column]) - 1, y1=max_value,
                           line=dict(color="red", width=1), name='max')
 
-        # Update layout
-        fig.update_layout(title=f"Cluster Centers for {column}",
-                          xaxis_title="Cluster Index",
-                          yaxis_title=column)
-        # Add the figure to the list
+        fig.update_layout(title=f"Cluster Centers for {column}", xaxis_title="Cluster Index", yaxis_title=column)
         figures.append(fig)
 
-    # Display the figures in a row format
     for fig in figures:
         st.plotly_chart(fig)
 
-
-    # Calculate max and min values for each cluster
     cluster_max_values = []
     cluster_min_values = []
 
     for i in range(optimal_k):
-        cluster_data = fake_data[cluster_labels == i]  # Get data points belonging to cluster i
-        cluster_max = np.max(cluster_data, axis=0)  # Calculate max values for each feature in the cluster
-        cluster_min = np.min(cluster_data, axis=0)  # Calculate min values for each feature in the cluster
+        cluster_data = fake_data[cluster_labels == i]
+        cluster_max = np.max(cluster_data, axis=0)
+        cluster_min = np.min(cluster_data, axis=0)
         cluster_max_values.append(cluster_max)
         cluster_min_values.append(cluster_min)
 
-    # Convert max and min values to DataFrame
     max_df = pd.DataFrame(cluster_max_values, columns=cluster_columns)
     min_df = pd.DataFrame(cluster_min_values, columns=cluster_columns)
 
-    # Add cluster names
     max_df['Cluster'] = [f'Cluster {i}' for i in range(optimal_k)]
     min_df['Cluster'] = [f'Cluster {i}' for i in range(optimal_k)]
 
-    # Display max and min values
-    # st.subheader('Max and Min Values for Each Cluster')
-    # st.write("Max Values:")
-    # st.write(max_df)
-    # st.write("Min Values:")
-    # st.write(min_df)
-
-    # Define a color palette for clusters
-    colors = px.colors.qualitative.Set1
-
-    # Create subplots
     fig = go.Figure()
 
-    # Plot min and max values for each column
     for i, column in enumerate(cluster_columns):
         for j in range(optimal_k):
             fig.add_trace(go.Bar(x=[f'Cluster {j} - Min', f'Cluster {j} - Max'],
                                  y=[min_df[column][j], max_df[column][j]],
                                  name=column,
-                                 marker_color=colors[j]))
+                                 marker_color=px.colors.qualitative.Set1[j]))
 
-    # Update layout
     fig.update_layout(title="Min and Max Values for Each Cluster",
                       xaxis_title="Cluster",
                       yaxis_title="Value",
                       barmode='group')
 
+    st.plotly_chart(fig)
+def clustering_for_evaluation():
+    cluster_mapping = {}
+    df = df_return()
+    for index, row in df.iterrows():
+        paired_with: int = row['Paired_With']  # Paired with resembles the ID column of the paired part
+        # Get the cluster of the paired part
+        paired_cluster = df.loc[df['ID'] == paired_with, 'Cluster'].values[0]
+        cluster_mapping[paired_with] = paired_cluster
+        # Create a new column to store the cluster label of the paired part
+        df['Paired Cluster'] = df['Paired_With'].map(cluster_mapping)
+
+    # Sample input dataframe
+    data = {
+        'Cluster_A': df['Cluster'].values,
+        'Cluster_B': df['Paired Cluster'].values,
+        'Evaluation': df['Evaluation'].values
+    }
+
+    contingency_df = pd.DataFrame(data)
+
+    # Create a list of unique clusters
+    clusters = list(set(contingency_df['Cluster_A']) | set(contingency_df['Cluster_B']))
+
+    # Initialize a dictionary to store combined cluster occurrences
+    combined_cluster_dict = {"Cluster A": [], "Cluster B": [], 'Combined_Cluster': [], 'Occurrence': [],
+                             'Num_OK': [],
+                             'Num_NOK': [], 'OK_Ratio': [], "Cluster_A_Name": [], "Cluster_B_Name": []}
+
+    # Iterate through each unique combination of clusters
+    for i, cluster_a in enumerate(clusters):
+        for cluster_b in clusters[i:]:
+            combined_cluster = f'{cluster_a}_{cluster_b}' if cluster_a <= cluster_b else f'{cluster_b}_{cluster_a}'
+            occurrence = 0
+            num_ok = 0
+            num_nok = 0
+
+            # Count occurrences, num_ok, and num_nok for the combination
+            for index, row in contingency_df.iterrows():
+                if (row['Cluster_A'] == cluster_a and row['Cluster_B'] == cluster_b) or \
+                        (row['Cluster_A'] == cluster_b and row['Cluster_B'] == cluster_a):
+                    occurrence += 1
+                    if row['Evaluation'] == 'OK':
+                        num_ok += 1
+                    else:
+                        num_nok += 1
+            # Calculate OK ratio
+            ok_ratio = num_ok / occurrence if occurrence > 0 else None
+
+            # Append data to the dictionary
+            combined_cluster_dict['Cluster A'].append(
+                cluster_a[-1:])  # Append only the number of the cluster for sorting purposes
+            combined_cluster_dict['Cluster_A_Name'].append(cluster_a)
+            combined_cluster_dict['Cluster B'].append(cluster_b[-1:])
+            combined_cluster_dict['Cluster_B_Name'].append(cluster_b)
+            combined_cluster_dict['Combined_Cluster'].append(combined_cluster)
+            combined_cluster_dict['Occurrence'].append(occurrence)
+            combined_cluster_dict['Num_OK'].append(num_ok)
+            combined_cluster_dict['Num_NOK'].append(num_nok)
+            combined_cluster_dict['OK_Ratio'].append(ok_ratio)
+
+    # Create the second dataframe
+    second_df = pd.DataFrame(combined_cluster_dict)
+    # sort the dataframe
+    second_df = second_df.sort_values(by=['Cluster A', 'Cluster B'], ascending=[True, True])
+    second_df = second_df.reset_index(drop=True)
+
+    st.dataframe(second_df, use_container_width=True)
+
+    # Create a matrix to hold the OK ratio values
+    matrix = pd.DataFrame(index=second_df['Cluster_A_Name'].unique(), columns=second_df['Cluster_B_Name'].unique())
+
+    # Populate the matrix with OK ratio values
+    for index, row in second_df.iterrows():
+        clusters = row['Combined_Cluster'].split('_')
+        matrix.loc[clusters[0], clusters[1]] = row['OK_Ratio']
+
+    # Plot heatmap using Plotly Express
+    fig = px.imshow(matrix.values.tolist(),
+                    labels=dict(x="Cluster 2", y="Cluster 1", color="OK Ratio"),
+                    x=matrix.columns,
+                    y=matrix.index,
+                    zmin=0.0,
+                    zmax=1.0,
+                    text_auto=True,
+                    color_continuous_scale='rdylgn')
+
+    fig.update_layout(
+        title='OK Ratio Heatmap of Cluster Pairs'
+    )
+
+    st.subheader('OK Ratio Heatmap of Cluster Pairs', anchor='heatmap')
     st.plotly_chart(fig)
 
 def main():
-    scatter_plot()
-    box_plot()
-    bar_chart()
-    kmeans()
-
+    st.markdown('<h1 style="text-align: center;">Box and Cylinder Analysis</h1>', unsafe_allow_html=True)
+
+    sections = {'Bar-Chart': 'Bar-Chart', 'Plot': 'Plot', 'K-Means': 'k-means'}
+
+    st.sidebar.title('PMV4')
+    selected_nav = st.sidebar.selectbox("Navigate to", list(sections.keys()), key='navigation')
+
+    if selected_nav:
+        st.session_state.selected_nav = sections[selected_nav]
+
+    nav = st.session_state.selected_nav
+
+    if nav == 'Bar-Chart':
+        bar_chart()
+        df_bar_chart_Evaluation()
+        df_bar_chart_fitting_group()
+    elif nav == 'Plot':
+        tab1, tab2 = st.tabs(["Box-Plot", "Scatter-Plot"])
+        with tab1:
+            st.header("Box-Plot")
+            box_plot()
+        with tab2:
+            st.header("Scatter-Plot")
+            scatter_plot()
+    elif nav == 'k-means':
+        kmeans_info_popover()
+        kmeans()
+        # clustering_for_evaluation()
 
 if __name__ == "__main__":
-    main()
+    main()
\ No newline at end of file
Index: .idea/shelf/Uncommitted_changes_before_Checkout_at_06_04_2024_11_04_[Changes]/shelved.patch
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Checkout_at_06_04_2024_11_04_[Changes]/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Checkout_at_06_04_2024_11_04_[Changes]/shelved.patch
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Checkout_at_06_04_2024_11_04_[Changes]/shelved.patch	
+++ /dev/null	
@@ -1,131 +0,0 @@
-Index: .idea/misc.xml
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"Black\">\r\n    <option name=\"sdkName\" value=\"Python 3.12 (ML_Stator_Hairline_Project)\" />\r\n  </component>\r\n  <component name=\"ProjectRootManager\" version=\"2\" project-jdk-name=\"Python 3.12 (ML_Stator_Hairline_Project)\" project-jdk-type=\"Python SDK\" />\r\n</project>
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/.idea/misc.xml b/.idea/misc.xml
---- a/.idea/misc.xml	(revision 429c0bdf498e1414e3eb9fcc9777380ba7a12a84)
-+++ b/.idea/misc.xml	(date 1711972871014)
-@@ -3,5 +3,5 @@
-   <component name="Black">
-     <option name="sdkName" value="Python 3.12 (ML_Stator_Hairline_Project)" />
-   </component>
--  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.12 (ML_Stator_Hairline_Project)" project-jdk-type="Python SDK" />
-+  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.12" project-jdk-type="Python SDK" />
- </project>
-\ No newline at end of file
-Index: .idea/ML_Stator_Hairline_Project.iml
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<module type=\"PYTHON_MODULE\" version=\"4\">\r\n  <component name=\"NewModuleRootManager\">\r\n    <content url=\"file://$MODULE_DIR$\">\r\n      <excludeFolder url=\"file://$MODULE_DIR$/venv\" />\r\n    </content>\r\n    <orderEntry type=\"inheritedJdk\" />\r\n    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\r\n  </component>\r\n</module>
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/.idea/ML_Stator_Hairline_Project.iml b/.idea/ML_Stator_Hairline_Project.iml
---- a/.idea/ML_Stator_Hairline_Project.iml	(revision 429c0bdf498e1414e3eb9fcc9777380ba7a12a84)
-+++ b/.idea/ML_Stator_Hairline_Project.iml	(date 1711972870955)
-@@ -4,7 +4,7 @@
-     <content url="file://$MODULE_DIR$">
-       <excludeFolder url="file://$MODULE_DIR$/venv" />
-     </content>
--    <orderEntry type="inheritedJdk" />
-+    <orderEntry type="jdk" jdkName="Python 3.12" jdkType="Python SDK" />
-     <orderEntry type="sourceFolder" forTests="false" />
-   </component>
- </module>
-\ No newline at end of file
-Index: .idea/workspace.xml
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"54c727bd-5502-4d94-92e6-ef0722eaca1d\" name=\"Changes\" comment=\"changed Compute_fit.py\">\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/main.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/main.py\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"FileTemplateManagerImpl\">\r\n    <option name=\"RECENT_TEMPLATES\">\r\n      <list>\r\n        <option value=\"Python Script\" />\r\n      </list>\r\n    </option>\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"GithubDefaultAccount\">\r\n    <option name=\"defaultAccountId\" value=\"517ed4f1-9889-4ab5-9540-d367fe4e53f3\" />\r\n  </component>\r\n  <component name=\"ProjectColorInfo\">{\r\n  &quot;associatedIndex&quot;: 7\r\n}</component>\r\n  <component name=\"ProjectId\" id=\"2dxb45aM3d1ulKtBGNNQ8EgcK55\" />\r\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\"><![CDATA[{\r\n  \"keyToString\": {\r\n    \"Python.Compute_fit.executor\": \"Run\",\r\n    \"Python.create_fake_data.executor\": \"Run\",\r\n    \"Python.main.executor\": \"Run\",\r\n    \"RunOnceActivity.OpenProjectViewOnStart\": \"true\",\r\n    \"RunOnceActivity.ShowReadmeOnStart\": \"true\",\r\n    \"git-widget-placeholder\": \"master\",\r\n    \"ignore.virus.scanning.warn.message\": \"true\",\r\n    \"node.js.detected.package.eslint\": \"true\",\r\n    \"node.js.detected.package.tslint\": \"true\",\r\n    \"node.js.selected.package.eslint\": \"(autodetect)\",\r\n    \"node.js.selected.package.tslint\": \"(autodetect)\",\r\n    \"nodejs_package_manager_path\": \"npm\",\r\n    \"settings.editor.selected.configurable\": \"org.jetbrains.plugins.github.ui.GithubSettingsConfigurable\",\r\n    \"vue.rearranger.settings.migration\": \"true\"\r\n  }\r\n}]]></component>\r\n  <component name=\"RunManager\" selected=\"Python.Compute_fit\">\r\n    <configuration name=\"Compute_fit\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"ML_Stator_Hairline_Project\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <EXTENSION ID=\"PythonCoverageRunConfigurationExtension\" runner=\"coverage.py\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/Compute_fit.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"create_fake_data\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"ML_Stator_Hairline_Project\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <EXTENSION ID=\"PythonCoverageRunConfigurationExtension\" runner=\"coverage.py\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/create_fake_data.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"main\" type=\"PythonConfigurationType\" factoryName=\"Python\" nameIsGenerated=\"true\">\r\n      <module name=\"ML_Stator_Hairline_Project\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <EXTENSION ID=\"PythonCoverageRunConfigurationExtension\" runner=\"coverage.py\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/main.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <recent_temporary>\r\n      <list>\r\n        <item itemvalue=\"Python.Compute_fit\" />\r\n        <item itemvalue=\"Python.create_fake_data\" />\r\n      </list>\r\n    </recent_temporary>\r\n  </component>\r\n  <component name=\"SharedIndexes\">\r\n    <attachedChunks>\r\n      <set>\r\n        <option value=\"bundled-python-sdk-d68999036c7f-b11f5e8da5ad-com.jetbrains.pycharm.pro.sharedIndexes.bundled-PY-233.14475.56\" />\r\n      </set>\r\n    </attachedChunks>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"54c727bd-5502-4d94-92e6-ef0722eaca1d\" name=\"Changes\" comment=\"\" />\r\n      <created>1710952482276</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1710952482276</updated>\r\n      <workItem from=\"1710952488034\" duration=\"1729000\" />\r\n      <workItem from=\"1711637649827\" duration=\"21285000\" />\r\n      <workItem from=\"1711793579912\" duration=\"9008000\" />\r\n    </task>\r\n    <task id=\"LOCAL-00001\" summary=\"changed Compute_fit.py\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1711797527397</created>\r\n      <option name=\"number\" value=\"00001\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1711797527397</updated>\r\n    </task>\r\n    <option name=\"localTasksCounter\" value=\"2\" />\r\n    <servers />\r\n  </component>\r\n  <component name=\"TypeScriptGeneratedFilesManager\">\r\n    <option name=\"version\" value=\"3\" />\r\n  </component>\r\n  <component name=\"VcsManagerConfiguration\">\r\n    <MESSAGE value=\"changed Compute_fit.py\" />\r\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"changed Compute_fit.py\" />\r\n  </component>\r\n  <component name=\"com.intellij.coverage.CoverageDataManagerImpl\">\r\n    <SUITE FILE_PATH=\"coverage/ML_Stator_Hairline_Project$create_fake_data.coverage\" NAME=\"create_fake_data Coverage Results\" MODIFIED=\"1711642715791\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$\" />\r\n    <SUITE FILE_PATH=\"coverage/ML_Stator_Hairline_Project$Compute_fit.coverage\" NAME=\"Compute_fit Coverage Results\" MODIFIED=\"1711796983528\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$\" />\r\n    <SUITE FILE_PATH=\"coverage/ML_Stator_Hairline_Project$main.coverage\" NAME=\"main Coverage Results\" MODIFIED=\"1711651733731\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$\" />\r\n  </component>\r\n</project>
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/.idea/workspace.xml b/.idea/workspace.xml
---- a/.idea/workspace.xml	(revision 429c0bdf498e1414e3eb9fcc9777380ba7a12a84)
-+++ b/.idea/workspace.xml	(date 1712394231366)
-@@ -5,8 +5,10 @@
-   </component>
-   <component name="ChangeListManager">
-     <list default="true" id="54c727bd-5502-4d94-92e6-ef0722eaca1d" name="Changes" comment="changed Compute_fit.py">
-+      <change afterPath="$PROJECT_DIR$/k_means.py" afterDir="false" />
-+      <change beforePath="$PROJECT_DIR$/.idea/ML_Stator_Hairline_Project.iml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/ML_Stator_Hairline_Project.iml" afterDir="false" />
-+      <change beforePath="$PROJECT_DIR$/.idea/misc.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/misc.xml" afterDir="false" />
-       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
--      <change beforePath="$PROJECT_DIR$/main.py" beforeDir="false" afterPath="$PROJECT_DIR$/main.py" afterDir="false" />
-     </list>
-     <option name="SHOW_DIALOG" value="false" />
-     <option name="HIGHLIGHT_CONFLICTS" value="true" />
-@@ -22,9 +24,6 @@
-   </component>
-   <component name="Git.Settings">
-     <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
--  </component>
--  <component name="GithubDefaultAccount">
--    <option name="defaultAccountId" value="517ed4f1-9889-4ab5-9540-d367fe4e53f3" />
-   </component>
-   <component name="ProjectColorInfo">{
-   &quot;associatedIndex&quot;: 7
-@@ -35,24 +34,24 @@
-     <option name="hideEmptyMiddlePackages" value="true" />
-     <option name="showLibraryContents" value="true" />
-   </component>
--  <component name="PropertiesComponent"><![CDATA[{
--  "keyToString": {
--    "Python.Compute_fit.executor": "Run",
--    "Python.create_fake_data.executor": "Run",
--    "Python.main.executor": "Run",
--    "RunOnceActivity.OpenProjectViewOnStart": "true",
--    "RunOnceActivity.ShowReadmeOnStart": "true",
--    "git-widget-placeholder": "master",
--    "ignore.virus.scanning.warn.message": "true",
--    "node.js.detected.package.eslint": "true",
--    "node.js.detected.package.tslint": "true",
--    "node.js.selected.package.eslint": "(autodetect)",
--    "node.js.selected.package.tslint": "(autodetect)",
--    "nodejs_package_manager_path": "npm",
--    "settings.editor.selected.configurable": "org.jetbrains.plugins.github.ui.GithubSettingsConfigurable",
--    "vue.rearranger.settings.migration": "true"
-+  <component name="PropertiesComponent">{
-+  &quot;keyToString&quot;: {
-+    &quot;Python.Compute_fit.executor&quot;: &quot;Run&quot;,
-+    &quot;Python.create_fake_data.executor&quot;: &quot;Run&quot;,
-+    &quot;Python.main.executor&quot;: &quot;Run&quot;,
-+    &quot;RunOnceActivity.OpenProjectViewOnStart&quot;: &quot;true&quot;,
-+    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,
-+    &quot;git-widget-placeholder&quot;: &quot;master&quot;,
-+    &quot;ignore.virus.scanning.warn.message&quot;: &quot;true&quot;,
-+    &quot;node.js.detected.package.eslint&quot;: &quot;true&quot;,
-+    &quot;node.js.detected.package.tslint&quot;: &quot;true&quot;,
-+    &quot;node.js.selected.package.eslint&quot;: &quot;(autodetect)&quot;,
-+    &quot;node.js.selected.package.tslint&quot;: &quot;(autodetect)&quot;,
-+    &quot;nodejs_package_manager_path&quot;: &quot;npm&quot;,
-+    &quot;settings.editor.selected.configurable&quot;: &quot;org.jetbrains.plugins.github.ui.GithubSettingsConfigurable&quot;,
-+    &quot;vue.rearranger.settings.migration&quot;: &quot;true&quot;
-   }
--}]]></component>
-+}</component>
-   <component name="RunManager" selected="Python.Compute_fit">
-     <configuration name="Compute_fit" type="PythonConfigurationType" factoryName="Python" temporary="true" nameIsGenerated="true">
-       <module name="ML_Stator_Hairline_Project" />
-@@ -125,6 +124,8 @@
-     </configuration>
-     <recent_temporary>
-       <list>
-+        <item itemvalue="Python.create_fake_data" />
-+        <item itemvalue="Python.Compute_fit" />
-         <item itemvalue="Python.Compute_fit" />
-         <item itemvalue="Python.create_fake_data" />
-       </list>
-@@ -148,6 +149,7 @@
-       <workItem from="1710952488034" duration="1729000" />
-       <workItem from="1711637649827" duration="21285000" />
-       <workItem from="1711793579912" duration="9008000" />
-+      <workItem from="1712393581695" duration="645000" />
-     </task>
-     <task id="LOCAL-00001" summary="changed Compute_fit.py">
-       <option name="closed" value="true" />
-diff --git a/k_means.py b/k_means.py
-new file mode 100644
Index: .idea/shelf/Uncommitted_changes_before_Checkout_at_06_04_2024_11_04__Changes_.xml
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Checkout_at_06_04_2024_11_04__Changes_.xml b/.idea/shelf/Uncommitted_changes_before_Checkout_at_06_04_2024_11_04__Changes_.xml
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Checkout_at_06_04_2024_11_04__Changes_.xml	
+++ /dev/null	
@@ -1,4 +0,0 @@
-<changelist name="Uncommitted_changes_before_Checkout_at_06_04_2024_11_04_[Changes]" date="1712394284044" recycled="true" deleted="true">
-  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Checkout_at_06_04_2024_11_04_[Changes]/shelved.patch" />
-  <option name="DESCRIPTION" value="Uncommitted changes before Checkout at 06/04/2024 11:04 [Changes]" />
-</changelist>
\ No newline at end of file
